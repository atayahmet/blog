<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[State Management Pattern nedir? Neden Kullanılır?]]></title>
      <url>/2018/02/16/State-Management-Pattern-nedir-Neden-Kullanilir/</url>
      <content type="html"><![CDATA[<p>Geniş çaplı uygulamaların karmaşıklık seviyesi, projenin büyüme hızıyla doğru orantılıdır. Özellikle proje javascript gibi bir dil ile geliştiriliyorsa <code>state management</code> gibi <code>design pattern</code>‘ların kullanımı zorunluluk hale geliyor.<br><a id="more"></a></p>
<p>Geniş çaplı uygulamaların karmaşıklık seviyesi, projenin büyüme hızıyla doğru orantılıdır. Özellikle proje javascript gibi bir dil ile geliştiriliyorsa <code>state management</code> gibi <code>design pattern</code>‘ların kullanımı zorunluluk hale geliyor.</p>
<p>UI (user interface) için kullanabileceğimiz bir çok framework’ün (Angular, VueJS, React, React Native) piyasaya çıkmasıyla yeni yöntemlerin uygulanmasına bağlı olarak bir takım sorunlar da beraberinde geldi. Bunlardan en önemlisi nesneler (objects), diziler (arrays) ve ilkel (primitive) türler dediğimiz string, boolean ve number türlerinin değişmezlik (immutable) yönetimleridir.</p>
<p>Kod performansını yüksek tutmak için mutable/immutable konusu önemli bir konudur. Bir <code>&lt;x-component&gt;</code>‘i içinde kullandığınız değişken <code>&lt;y-component&gt;</code>‘i için de değişme (mutate) riski taşıyacağından bu da beraberinde bir takım bug’ları getiriyor olacaktır. Bu tür sorunların debugging işlemi bir hayli sancılı olmaktadır.</p>
<p>Bir değişkeni reference olarak değil yeni bir kopyasını (clone) oluşturarak farklı yerlerde kullanılması çok daha doğru bir adım olacaktır. Immutable kavramının tam olarak tanımı için; “Herhangi bir türe sahip değişkenin değerini asla değiştirme. Yeni bir kopyasını oluştur ve kullan.” şeklinde açıklayabiliriz.</p>
<p>Neden peki değişkenleri istediğimiz yerde istediğimiz şekilde kullanamıyoruz yada değiştiremiyoruz? Aslında bu sorunun cevabı kullandığımız UI framework’lerin <code>data-bind</code> mimarisi üzerine kurulu olmasıyla ilgili bir durum. Özetle component içinde bir değişken ile html elementini birbirine bağlayarak (binding) arada bir ilişki kuruluyor. Bu iki uç nokta sürekli olarak birbirleriyle etkileşim içinde oluyorlar.</p>
<blockquote>
<p><strong>Not:</strong> Data-Binding iki yönlü (two-way) ya da tek yönlü (one-way) olabilir. Kullanılan teknolojiye göre farklılık gösterebilir. İki yönlü binding mimarisi, bind edilen değişken mevcut değerinden farklı bir değer ile değiştirilirse bu değişim direkt olarak UI’a yansıyacaktır. Aynı şekilde html içindeki bir input yada vb. form element ile bind edilmiş ise bu elemente girilecek olan her değer direkt olarak değişkeni etkileyecektir.</p>
</blockquote>
<p>Bind edilmiş bir değişken ile element her hangi bir değişime karşı birbirlerini sürekli dinliyor olacaklardır. Bir değişkenin değeri her değiştiğinde direkt olarak componentin kendini tekrar render etmesini sağlayacaktır. Peki ama aynı değişken bir den fazla component için de aynı referans ile kullanıldığında olacakları bir düşünün? Tek bir değişkenin mutate olması bir çok componenti tekrar tekrar render olmaya zorlayacaktır. Bu durum performans sorunlarını beraberinde getirecektir.</p>
<p>Yukarıdaki hata senaryolarının çözümü state management kullanımında yatmaktadır. Neyseki bir çok framework bu pattern’ı kendi bünyelerine entegre ederek kullanımını teşvik etmektedir. Aksi halde frensiz bir arabayla yolculuk yapmak gibi riskli bir geliştirme süreci kaçınılmaz olacaktır.</p>
<h2 id="Temel-ozellikleri"><a href="#Temel-ozellikleri" class="headerlink" title="Temel özellikleri"></a>Temel özellikleri</h2><p>State management temel de 3 farklı bileşini vardır. Bunlar;</p>
<ul>
<li>Store</li>
<li>Actions</li>
<li>Reducers</li>
</ul>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store tüm değişkenlerin muhafaza edileceği (in-memory) kısım. Veriler buraya kaydedilip kullanılmak istenildiğin de tekrar buradan elde edilecektir.</p>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>Bir değişken/sabit yada class olarak kullanılabilmektedir. Store ile veri alışverişi yapılırken her işlemi temsil edecek olan bir kimlik olarak düşünebiliriz. Genel de açıklayıcı niteliği taşıyan değerler atanır.</p>
<p>Örnek:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> REMOVE_ITEM_ACTION = <span class="string">'[Todo] Remove item'</span></div></pre></td></tr></table></figure></p>
<h3 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a>Reducers</h3><p>Reducer aşaması store’daki veriyi işleme görevini yapacak olan kısımdır. Action’lar ile iletişim kurar ve mutate işlemlerini gerçekleştirir. Daha sonra veriyi tekrar store’a yazar ve yeni bir kopyasını kullanılmak üzere geri döndürür.</p>
<h2 id="Avantajlari"><a href="#Avantajlari" class="headerlink" title="Avantajları"></a>Avantajları</h2><p>En büyük avantajı hiç şüphesiz in-memory veri yığınının daha tutarlı kullanımına  imkan sağlaması. Yazının girişin de bahsettiğimiz gibi büyük ölçekli projeler de en büyük risk immutable yönetemidir. </p>
<p>Bir diğer avantaj cache imkanı sunuyor olması. Browser ortamın da çalışan sistemler de store’a eklenen verilerin tekrar API sorgusuna gerek kalmadan kullanılabilir olmasıdır. </p>
<h2 id="Dezavantajlari"><a href="#Dezavantajlari" class="headerlink" title="Dezavantajları"></a>Dezavantajları</h2><p>Avantaj olarak gördüğümüz cache’leme kolaylığı iyi yönetilemezse dezavantaj olarak önümüze geri gelecektir. Çok fazla kaynak tüketimi (memory leak) olacağından tarayıcı ortamında (özellikle mobil tarayıcılar da) ciddi performans sorunlarına yol açabilir.</p>
<h2 id="Sonuc"><a href="#Sonuc" class="headerlink" title="Sonuç"></a>Sonuç</h2><p>Sonuç olarak client (özellikle SPA) projeler de kullanmamız faydalı olacaktır. Avantajları ve dezavantajlarının göz önünde bulundurulması gerektiğini unutmamalıyız. </p>
<p>Günümüz tarayıcılarının imkanları geniş ve modern teknolojilere hızlıca destek veriyor olsalar da sınırsız olmadığını unutmamak lazım.</p>
<p>Aşağıda her hangi bir framework’e bağımlı kalmadan kullanabileceğiniz bir kaç State Management library repo’ları paylaştım.</p>
<p><a href="https://redux.js.org/" target="_blank" rel="noopener">https://redux.js.org/</a><br><a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">https://facebook.github.io/immutable-js/</a><br><a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">https://github.com/mobxjs/mobx</a></p>
]]></content>
      
        <categories>
            
            <category> Yazılar </category>
            
            <category> Javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design pattern </tag>
            
            <tag> javascript </tag>
            
            <tag> state management </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Repository Pattern Nedir? Kullanımındaki avantajlar nelerdir?]]></title>
      <url>/2017/08/14/Repository-Pattern-Nedir-Kullanimindaki-avantajlar-nelerdir/</url>
      <content type="html"><![CDATA[<p>Repository Pattern büyük ölçekli projelerde tercih edilen design pattern mimarilerinden biridir.<br><a id="more"></a></p>
<p>Repository Pattern büyük ölçekli projelerde tercih edilen design pattern mimarilerinden biridir. Domain Driven Design mimarisinin bir parçası olarak 2004 yılında ilk olarak duyurulmuştur. Veriye erişimi olan objeleri izole ederek (encapsulation) direkt erişime kapatır,  bu iletişim repository üzerinden yapılır. </p>
<p>Repository Pattern tasarımının bir dil kısıtlaması yoktur. Her yazılım dilinde uygulanabilmektedir.</p>
<p>Bu soyut kavramı kafamızda biraz daha somutlaştıralım ve örneklendirmeye çalışalım.</p>
<p>Repository Pattern aslında bir veri soyutlama yöntemidir. Bu soyutlama işlemini gerçekleştirirken katmanlardan faydalanılmaktadır. </p>
<p>Projede veritabanı işlemlerini  (Data Access Object) bir katmanda, veri erişim isteğinde bulunan kısım (Client) bir katmanda ve son olarak bu iki katman arasındaki iletişimi sağlayacak olan kısımı (Business Logic) bir katmanda düşünelim. Client veriye erişmek istediğinde repository katmanına başvurur. Repository katmanı istenilen veriyi Data Access Object katmanından alır ve tekrar Client katmanına döndürür. </p>
<p>Özetle Repository Pattern yaşam döngüsü (Life Cycle) bu şekilde çalışmaktadır.</p>
<p>Repository katmanını her hangi bir yazılım dilinde sınıf (class) olarak düşünüğümüzde, sıklıkla kullandığımız methodları bu sınıf için de ortak amaçlar için barındırırız. Böylelikle bize özel collection-like sınıfları sağlamaktadır. </p>
<p>Metodlar:</p>
<ul>
<li>create()</li>
<li>read()</li>
<li>update()</li>
<li>delete()</li>
</ul>
<p>Bu metodlar en çok kullanılanlarıdır. Tabi ki farklılaşabilir fakat kod tekrarına (dublication) sürüklenmemek için dikkat edilmelidir. Çünkü Repository Pattern  mimarisinin sağladığı en büyük avantajlardan biri kod tekrarının en aza indirme fırsatı vermesidir.</p>
<p>PHP ile basit bir örnek yaparak prensipleri uygulayalım.</p>
<p>İlk olarak Repository adında bir sınıf oluşturalım.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repository</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> $model;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($model)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;model = $model;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span><span class="params">($data)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;model-&gt;create($data);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">($data, $id)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;model-&gt;update($id, $data);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delete</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;model-&gt;delete($id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Yukarıda en çok kullanılan bazı metodları sınıfa ekledik. Sonra veritabanı işlemlerini yapacak olan modeli sınıf içine bağımlılık olarak gönderdik. </p>
<blockquote>
<p>Not: Model konusu farklı bir başlık konusu olduğundan detayına girilmeyecektir. Sadece veritabanı işlemlerini yapan ve veri nesnelerine erişimi sağlayan katman olarak anılacaktır.</p>
</blockquote>
<p>Şimdi de model sınıfımızı oluşturalım.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientModel</span> <span class="keyword">extends</span> <span class="title">SomeORM</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// bu sınıf belki bir ORM sınıfına yada benzeri ilişkisel veri modelleme sınıflarına genişletilebilir. Belki kendinizin geliştirmiş olduğu bir ORM 'i entegre edebilirsiniz.</span></div><div class="line">  <span class="comment">// şimdilik sadece create(), update(), delete() methodlarının olduğunu varsayalım.</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Yukarıdaki basit sınıfları oluşturduktan sonra ClientModel’i repository sınıfına bağımlılık parametresi olarak gönderiyoruz.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$model = <span class="keyword">new</span> ClientModel;</div><div class="line"></div><div class="line">$clientRepository = <span class="keyword">new</span> Repository($model);</div></pre></td></tr></table></figure>
<p>Client Model ile veri erişim işlemlerini yapabileceğimiz bir repository sınıfımız var. </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$clientRepository-&gt;create($data);</div><div class="line"></div><div class="line">$clientRepository-&gt;update($data, $id);</div></pre></td></tr></table></figure>
<p>İstersek bunu CategoryModel yapabilirdik. Bu ihtiyaçlarımıza göre çeşitlenecek bir gelişme.</p>
<p>CategoryModel’imiz olduğunu düşünürsek:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$model = <span class="keyword">new</span> CategoryModel;</div><div class="line"></div><div class="line">$categoryRepository = <span class="keyword">new</span> Repository($model);</div></pre></td></tr></table></figure>
<p>Daha da ileri taşıyacak olursak repository sınıflarınıda genişleterek (extends) daha spesifik kurgular yapabiliriz. Bu tamamen iş mantığı (business logic)’na bağlı bir durum.</p>
<p><strong>Örnek:</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($model)</span></span></div><div class="line">  &#123;</div><div class="line">      <span class="keyword">parent</span>::__contruct($model);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">mutateAndCreate</span><span class="params">($data)</span></span></div><div class="line">  &#123;</div><div class="line">      <span class="keyword">unset</span>($data[<span class="string">'phone'</span>]);</div><div class="line">      </div><div class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;create($data);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">$model = <span class="keyword">new</span> Client;</div><div class="line"></div><div class="line">$clientRepository = <span class="keyword">new</span> ClientRepository($model);</div><div class="line"></div><div class="line">$client-&gt;mutateAndCreate($data);</div></pre></td></tr></table></figure>
<p>Yukarıda Repository sınıfını ClientRepository sınıfına genişlettiğimizi görüyoruz. Sonrasında $model katmanını bu sınıfa bağımlılık sınıfı olarak gönderiyoruz. </p>
<p>Burda yeni oluşturduğumuz ClientRepository sınıfının yapılandırma (construct) metodunda, ana Repository sınıfının yapılandırma (construct) metodunu çağırdığımızı (parent::__construct()) görüyoruz. Çünkü ana Repository sınıfımız $model katmanına bağımlı olduğundan bu işlemi yapmamız gerekmektedir. </p>
<p>Repository pattern mimarisinin avantajlarından bir tanesi sadece tek yönlü bağımlılığı olmasıdır. Bu bize bağımlılık yönetiminde forsatlar sunmaktadır.</p>
<p>Kolay ve hızlıca anlaşılması için yukarıdaki örneği olabildiğince basit anlatmaya çalıştım. Çok daha gelişmiş örnekleri bir kaç arama ile rahatlıkla bulabilirsiniz.</p>
]]></content>
      
        <categories>
            
            <category> Yazılar </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design pattern </tag>
            
            <tag> data mapper </tag>
            
            <tag> collection-like </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript'te Hoisted Variables & Functions nedir?]]></title>
      <url>/2017/08/02/Javascript-te-Hoisted-Variables-Functions-nedir/</url>
      <content type="html"><![CDATA[<p>Javascript’de yeni olanların ilk karşılaştıklarında kafalarını karıştırabilecek bir konu olan hoisted variables &amp; functions konusu anlatmaya çalışacağım. Hosited nedir peki? Ne işe yarar?<br><a id="more"></a></p>
<h2 id="Hoisted-Variables"><a href="#Hoisted-Variables" class="headerlink" title="Hoisted Variables:"></a>Hoisted Variables:</h2><p>Javascript’te değişkenlerimizi <code>var</code>, <code>let</code> ve <code>const</code> gibi türlerle tanımlarız (declaration). Sonrasında bir değer atayarak değişkeni kullanıma hazır hale getiriz. İşte tam da burada değişkeni nerede tanımladığımızın çok büyük önemi vardır. Bir çok yazılım dillerinde değişken tanımlama işlemi kod akışında en başta tanımlamayı gerektirir. Yada kullanımından önce değerinin atanmış olması gerekir.</p>
<p>Örnek verelim:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'Merhaba'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Merhaba</span></div></pre></td></tr></table></figure>
<p>Normal şartlarda her zaman bir değişkeni yukarıdaki gibi tanımlayıp kullanırız.</p>
<p>Başka bir örnek ile devam edelim:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'Merhaba'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="string">'Selam'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Merhaba</span></div></pre></td></tr></table></figure>
<p>İki tane <code>a</code> değişkeni oluşturduk fakat bir tanesi global kapsamda yani window nesnesine kaydedildi. Diğerini ise <code>x</code> fonksiyonu içinde tanımlandık. Çıktının <strong>Merhaba</strong> olduğunu görebiliyoruz. Tanımlanan değişkenlerin sadece kendi scope’larından erişilebildiğini, scope dışında kalan alanlarda değişkenin aslında hiç oluşturulmadığını görürüz.</p>
<p>Tanımlanmayan (undeclared) bir değişkeni kullanmak istediğimizde <code>ReferenceError</code> istisnasının fırlatıldığını hatırlatalım.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(c) <span class="comment">// throws ReferenceError</span></div></pre></td></tr></table></figure>
<p>Bir değişken tanımlanıp fakat bir değer atanmadığında varsayılan değeri <code>undefined</code> olur.</p>
<p><strong>Örnek:</strong> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></div><div class="line"></div><div class="line">b = <span class="string">'Istanbul'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Istanbul</span></div></pre></td></tr></table></figure>
<p>Bir diğer ayrıntı ise değişken tanımlarken türünü belirtmezsek eğer global kampasamda tanımlanmış olur. Yani tür tanımlanmayan bir değişken, fonksiyon içinde tanımlanmış dahi olsa kodumuzun her hangi bir yerinden erişebiliriz.</p>
<p><strong>Örnek:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  name = <span class="string">'Ahmet'</span>;</div><div class="line">  <span class="keyword">var</span> surname = <span class="string">'ATAY'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">y(); <span class="comment">// call</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Ahmet</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(surname); <span class="comment">// throws ReferenceError</span></div></pre></td></tr></table></figure>
<h2 id="Hoisted-Functions"><a href="#Hoisted-Functions" class="headerlink" title="Hoisted Functions"></a>Hoisted Functions</h2><p>Fonksiyon tanımlarken farklı yöntemler kullanılabilir. Javascript’in bizi şaşırtan bir takım özellikleri burada ortaya çıkıyor.</p>
<p>Bir örnek verelim:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">merhaba(); <span class="comment">// Merhaba</span></div><div class="line"></div><div class="line"><span class="comment">// function declaration</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merhaba</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Merhaba'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">gunaydin(); <span class="comment">// ReferenceError: gunaydin is not defined</span></div><div class="line"></div><div class="line">selam(); <span class="comment">// TypeError undefined is not a function</span></div><div class="line"></div><div class="line"><span class="comment">// function express</span></div><div class="line"><span class="keyword">var</span> selam = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Selam'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Yukarıdaki kullanımları sırasıyla açıklayalım;</p>
<p>İlk olarak <code>merhaba()</code> fonksiyonunu çağırdık ve beklediğimiz çıktıyı aldık. Burada şu soruyu soruyor olabilirsiniz; fonksiyon tanımlandığı yerden önce çalıştırıldı. Evet ilk bakışta kafa karıştıcı geliyor. Function hoisting tanımlanmış olan fonksiyonları scope’ta üste taşıma işlemi anlmaına gelmketedir. Böylelikle tanımlama işlemi çalıştırma işleminden önce gerçekleşmiş olur.</p>
<p>Hala daha kafanızda bu konu ile ilgili soru işaretleri var ise şöyle bir açıklama yapabilirim. Tarayıcılardaki Javascript yorumlayıcıları tüm kodları çalışma anında (Runtime) bazı düzenlemelerden sonra çalıştırır. Hoisting işlemide bu düzenleme kapsamında uygulanmaktadır.</p>
<p>Pratikte değişken tanımlamaları her zaman akışa göre üste olması, kod içinde oluşabilecek <code>declaration</code> kargaşasının önüne geçmek için doğru bir yol olacaktır.</p>
<p>Yazının faydalı olması dileğiyle.</p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> hoisting </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VueJS 2 Custom Event ile ilgili bir kaç ayrıntı]]></title>
      <url>/2017/04/29/VueJS-Custom-Event-ile-ilgili-bir-kac-ayrinti/</url>
      <content type="html"><![CDATA[<p>VueJS 2 ile birlikte gelen yeniliklerin yanı sıra hali hazırdaki bir takım özellikler de kaldırıldı (depracated) ya da kullanım şekli değiştirildi diyebiliriz. Yeni versiondan etkilenen özelliklerden biri de Custom Event’lerin kullanımlarıdır.<br><a id="more"></a><br>Şöyleki; VueJS version 1’de parent instance’tan child component’te kaydedilmiş bir event yada event’leri <code>$broadcast</code> edebiliyorduk diğer bir söylemle tetikleyebiliyorduk. Şuan da version 2’de bu özellik resmi olarak kaldırılmış durumda, yani parent’tan child componentteki bir event’leri çalıştıramıyoruz.</p>
<p>Artık sadece child component’ten parent instance’taki event’leri çalıştırabiliyoruz. Burada yine bir kullanım dğeişikliği söz konusu, version 1’de <code>$dispatch</code> ile child component’ten parent’taki bir event tetikliyorken, version 2’de bu süreç artık tamamen event directive’leri üzerinden ilerliyor.</p>
<p><strong><em>Parent-Child event yönetimi ile ilgili dökümanda bulunan ayrıntı:</em></strong><br><blockquote><p>You cannot use $on to listen to events emitted by children. You must use v-on directly in the template, as in the example below.</p>
<footer><strong>VueJS 2 Document</strong><cite><a href="https://vuejs.org/v2/guide/components.html#Custom-Events" target="_blank" rel="noopener">Custom Events</a></cite></footer></blockquote></p>
<p>Örnek:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">products</span> <span class="attr">v-on:alert</span>=<span class="string">"alerts"</span>&gt;</span><span class="tag">&lt;/<span class="name">products</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Products Component:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'products'</span>, &#123;</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    getProducts() &#123;</div><div class="line">      <span class="keyword">this</span>.$emit(<span class="string">'alert'</span>, <span class="string">'Ürün bulunamadı'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Product List Component (parent):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    alerts(message) &#123;</div><div class="line">      <span class="comment">// Ürün bulunamadı</span></div><div class="line">      <span class="built_in">console</span>.log(message);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;).$mount(<span class="string">'example'</span>);</div></pre></td></tr></table></figure>
<p>Sonuç itibariyle</p>
<p>Üzerinde çalıştığım projede parent instance’tan child component’teki bir event’i tetiklemem gerektiğinden bunu farklı bir yöntemle çözdüm. One-way binding yapıp child component’te tanımladığım prop’u VueJS watch ile izleyerek bir nevi event gibi kullanmış oldum. </p>
<p>Yöntem çok doğru olmasada version 2’de bu durumu çözecek her hangi bir püf nokta bulamadım. Eğer bu durumu çözecek bir fikri olan birileri varsa yorumda bunu belirtebilirse beni ve ihtyacı olanları ihya edecektir.</p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
            <category> VueJS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> VueJS </tag>
            
            <tag> Custom Events </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
